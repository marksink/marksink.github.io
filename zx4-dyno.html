<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wheel Torque</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { background-color: #111; color: white; font-family: Arial, sans-serif; }
    #plot {
      width: 90%;
      max-width: calc(100vh * (16 / 9));   /* Prevent width:height exceeding 16:9 */
      aspect-ratio: 16 / 9;                 /* Always maintain 16:9 ratio */
      max-height: 90vh;                     /* Ensure graph fits vertically in viewport */
      margin: auto;
    }
    .controls { text-align: center; margin-bottom: 20px; }
    .controls > * { margin: 0 6px; }
    button { margin-left: 10px; }
    label { user-select: none; }
  </style>
</head>
<body>
  <h1 style="text-align:center;">Kawasaki ZX-4R</h1>
  <div class="controls">
    <label for="front">Front Sprocket:</label>
    <select id="front" onchange="plotTorque(true)">
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14" selected>14</option>
      <option value="15">15</option>
    </select>

    <label for="rear">Rear Sprocket:</label>
    <select id="rear" onchange="plotTorque(true)">
      <option value="43">43</option>
      <option value="44">44</option>
      <option value="45">45</option>
      <option value="46">46</option>
      <option value="47">47</option>
      <option value="48" selected>48</option>
      <option value="49">49</option>
      <option value="50">50</option>
      <option value="51">51</option>
      <option value="52">52</option>
      <option value="53">53</option>
    </select>

    <label for="hpData">HP Data:</label>
    <select id="hpData" onchange="plotTorque(true)"></select>

    <label for="viewSelect">View:</label>
    <select id="viewSelect" onchange="plotTorque(true)">
      <option value="wheel" selected>Wheel TQ</option>
      <option value="dyno">Dyno</option>
    </select>

    <label id="clipControl">
      <input type="checkbox" id="truncateCross" onchange="plotTorque(false)">
      Clip Lines
    </label>

    <button onclick="freezeCurrentTraces()">Compare</button>
    <button onclick="clearFrozenTraces()">Reset</button>
  </div>

  <div id="plot" style="position: relative;">
    <div id="freezeNotification" style="
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255,255,255,0.9);
        color: #111;
        padding: 8px 12px;
        border-radius: 4px;
        font-weight: bold;
        display: none;
        z-index: 1000;
    ">
      Select New Options!
    </div>
  </div>

  <script>
    // -------- Constants & data --------
    const primary_drive = 2.029;
    const tire_circ_in  = 77.15;
    const gear_ratios   = {1:2.92, 2:2.05, 3:1.62, 4:1.33, 5:1.15, 6:1.03};

    const hp_data_sets = {
  Stock: [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    11.85,12.4,13.23,13.92,14.88,15.43,15.98,16.26,16.67,17.22,17.91,18.74,19.15,19.7,19.98,19.98,20.26,20.81,21.77,22.6,23.01,23.43,24.11,24.8,25.49,25.77,26.18,26.73,27.01,27.28,27.83,28.25,28.66,29.07,29.63,29.76,29.9,30.04,30.45,31.0,31.56,32.24,32.8,33.21,33.9,34.45,34.86,35.69,36.24,36.93,37.2,37.62,38.44,39.27,40.24,41.06,42.03,42.44,43.13,43.82,44.23,44.51,44.92,45.61,46.3,47.13,47.81,48.37,48.92,49.74,50.71,51.54,52.36,53.05,53.74,54.57,55.26,55.81,56.22,56.77,57.05,57.32,57.46,57.6,57.05,56.36,56.08,56.22,56.36,56.08,55.94,55.53,55.53,55.26,54.43,54.02,53.74,53.74,53.74,53.74,53.6,53.19,53.05,53.05,52.91,52.78,52.64,52.64,52.5,52.5,52.22,52.09,51.81,51.26,50.85,50.43,49.88,49.47,48.92,48.37,47.95,47.54,47.13,46.44,45.61,44.78,44.37
  ][i]]),

  Tuned: [
    3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600,14700,14800,14900,15000,15100,15200,15300,15400,15500,15600,15700,15800,15900,16000
  ].map((rpm, i) => [rpm, [
    12.93,13.75,14.72,15.27,15.82,16.23,16.64,17.05,17.47,17.74,18.15,18.43,18.7,19.12,19.53,20.22,20.9,21.18,21.73,22.14,22.69,23.1,23.79,24.07,24.2,24.89,25.58,26.4,26.68,27.09,27.64,28.06,28.47,29.02,29.43,29.98,30.53,31.08,31.77,32.32,33.01,33.56,34.24,35.07,35.62,36.17,36.58,37.27,37.68,38.37,39.06,39.61,40.02,40.57,41.26,42.08,42.91,44.28,45.11,45.93,46.48,47.03,47.45,47.86,48.13,48.68,49.23,50.06,50.88,51.43,52.12,53.08,53.91,54.73,55.7,56.39,57.07,57.62,58.04,58.86,59.96,60.24,60.37,60.65,61.2,61.34,61.61,62.02,62.71,63.26,63.67,64.22,64.77,65.6,65.87,66.01,66.84,67.39,67.94,68.49,68.62,69.17,69.72,70.55,71.1,71.24,71.38,71.38,71.51,71.51,71.24,70.83,70.41,70.14,69.59,69.04,68.21,67.11,66.42,65.74,65.05,64.22,63.4,62.44,61.47,60.51,59.55
  ][i]])
  // ,

  // "ACME Slip-on": [
  //   3500, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500,
  //   8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000,
  //   12500, 13000, 13500, 14000, 14250, 14500, 15000, 15500, 16000
  // ].map((rpm, i) => [rpm, [
  //   14.07, 17.54, 19.64, 22.16, 24.26, 26.99, 29.61, 32.24, 34.76,
  //   38.01, 40.74, 44.94, 49.35, 51.66, 55.23, 59.64, 63.00, 64.68,
  //   66.68, 71.41, 74.03, 77.66, 78.29, 79.92, 78.19, 74.48, 67.73
  // ][i]])
  // ,

  // "Ninja 400": [
  //   3700, 3800, 3900, 4000, 4100, 4200, 4300, 4400, 4500, 4600,
  //   4700, 4800, 4900, 5000, 5100, 5200, 5300, 5400, 5500, 5600,
  //   5700, 5800, 5900, 6000, 6100, 6200, 6300, 6400, 6500, 6600,
  //   6700, 6800, 6900, 7000, 7100, 7200, 7300, 7400, 7500, 7600,
  //   7700, 7800, 7900, 8000, 8100, 8200, 8300, 8400, 8500, 8600,
  //   8700, 8800, 8900, 9000, 9100, 9200, 9300, 9400, 9500, 9600,
  //   9700, 9800, 9900, 10000, 10100, 10200, 10300, 10400, 10500,
  //   10600, 10700, 10800, 10900, 11000, 11100, 11200, 11300, 11400,
  //   11500, 11600, 11700, 11800, 11900, 12000, 12100
  // ].map((rpm, i) => [rpm, [
  //   13.05,14.22,15.28,16.0,17.06,17.84,18.51,19.28,19.73,20.45,21.18,21.68,22.18,22.46,22.73,23.07,23.29,23.85,24.35,24.68,25.52,26.24,26.85,27.41,27.52,27.52,27.85,28.8,30.14,30.52,31.19,31.92,32.58,33.14,33.7,34.42,35.2,35.81,36.09,36.09,36.53,37.59,38.48,39.15,39.87,40.65,40.93,41.21,41.43,41.65,42.21,42.38,42.66,42.99,43.49,43.93,44.49,44.94,45.05,45.05,45.05,45.05,45.05,45.05,44.94,44.77,44.49,44.1,43.82,43.71,43.66,43.6,43.49,43.27,43.27,43.27,43.04,42.77,42.77,42.6,42.49,42.49,42.21,41.88,41.88
  // ][i]])
};


    // Precompute Dyno view y-axis maximum based on max HP across all datasets
    const dynoMaxHP = (() => {
      let maxVal = 0;
      Object.values(hp_data_sets).forEach(arr => {
        arr.forEach(([rpm, v]) => { if (v > maxVal) maxVal = v; });
      });
      // Round up to nearest 10
      return Math.ceil(maxVal / 10) * 10;
    })();

    const gear_colors = ['#FF0000', '#00FFFF', '#00FF00', '#FFFF00', '#F012BE', '#FFFFFF'];

    // Available dash styles for frozen traces
    const freezeDashStyles = ['dot', 'dash', 'longdash', 'dashdot', 'solid'];
    let freezeCount = 0;

    // Number of interpolated data points per curve
    const densePoints = 750;

    // Compute min/max RPMs from data sets
    const rpm_data_raw = hp_data_sets[Object.keys(hp_data_sets)[0]].map(([r, _]) => r);
    // Create a dense RPM array from min to max of rpm_data
    const rpmDense = (() => {
      const arr = [];
      const minR = rpm_data_raw[0];
      const maxR = rpm_data_raw[rpm_data_raw.length - 1];
      for (let i = 0; i <= densePoints; i++) {
        arr.push(minR + (maxR - minR) * (i / densePoints));
      }
      return arr;
    })();

    // Generate dense HP datasets by interpolating original dyno data
    const hpDenseSets = {};
    for (const key in hp_data_sets) {
      const rpmArrRaw = hp_data_sets[key].map(([r, hp]) => r);
      const hpArrRaw = hp_data_sets[key].map(([r, hp]) => hp);
      hpDenseSets[key] = rpmDense.map(r => interp1(rpmArrRaw, hpArrRaw, r));
    }

    // Populate HP Data dropdown with available datasets
    function populateHpDropdown() {
      const sel = document.getElementById('hpData');
      sel.innerHTML = '';
      const keys = Object.keys(hp_data_sets);
      keys.forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = k;
        sel.appendChild(opt);
      });
      // Default to Stock if present, otherwise first key
      if (keys.includes('Stock')) sel.value = 'Stock';
      else if (keys.length) sel.value = keys[0];
    }

    // -------- Globals --------
let frozenTraces = [];
let frozenConnectorTraces = [];
let previousTraces = [];
let maxX = 0, maxY = 0;

let lastView = null;

    // -------- Helpers --------
    function rpmToSpeed(rpm, gear_ratio, final_drive) {
      return rpm * tire_circ_in / (primary_drive * gear_ratio * final_drive * 1056);
    }

    function hpToWheelTorqueAt(rpmArr, hpArr, gear_ratio, final_drive) {
      const overall = primary_drive * gear_ratio * final_drive;
      return rpmArr.map((rpm, i) => (hpArr[i] * 5252 / rpm) * overall);
    }

    function lerp(x1, y1, x2, y2, y) {
      return x1 + (y - y1) * (x2 - x1) / (y2 - y1);
    }

    function interp1(xArr, yArr, x) {
      if (x <= xArr[0]) return yArr[0];
      if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
      let lo = 0, hi = xArr.length - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (xArr[mid] <= x) lo = mid; else hi = mid;
      }
      const x1 = xArr[lo], x2 = xArr[hi];
      const y1 = yArr[lo], y2 = yArr[hi];
      return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
    }

    // Compute optimal crossover shift RPMs and speeds
    function computeShiftPoints(hpArr, final_drive, rpmArr) {
      const wt = {}, spd = {};
      for (let g = 1; g <= 6; g++) {
        wt[g]  = hpToWheelTorqueAt(rpmArr, hpArr,      gear_ratios[g], final_drive);
        spd[g] = rpmArr.map(rpm => rpmToSpeed(rpm, gear_ratios[g], final_drive));
      }

      const shift_rpm   = {};
      const shift_speed = {};

      for (let g = 1; g <= 5; g++) {
        const ratio  = gear_ratios[g + 1] / gear_ratios[g];
        const diff   = [];

        for (let i = 0; i < rpmArr.length; i++) {
          const rp    = rpmArr[i];
          const curTq = wt[g][i];
          const nxtTq = interp1(rpmArr, wt[g + 1], rp * ratio);
          diff.push(nxtTq - curTq);
        }

        let idx = diff.findIndex(d => d >= 0);
        let shiftRPM;
        if (idx === -1) {
          shiftRPM = rpmArr[rpmArr.length - 1];
        } else if (idx === 0) {
          shiftRPM = rpmArr[0];
        } else {
          shiftRPM = lerp(
            rpmArr[idx - 1], diff[idx - 1],
            rpmArr[idx],     diff[idx],
            0
          );
        }

        shift_rpm[g]   = shiftRPM;
        shift_speed[g] = rpmToSpeed(shiftRPM, gear_ratios[g], final_drive);
      }

      return { wt, spd, shift_rpm, shift_speed };
    }

    // Pre-compute axis bounds
    function getPlotBounds() {
      const all_hp = Object.values(hp_data_sets);
      const fd_ratios = [48/13, 48/14, 50/13, 50/14];
      for (const gr of Object.values(gear_ratios)) {
        for (const hpArr of all_hp) {
          const rpmArrRaw = hpArr.map(([r, hp]) => r);
          const hpArrRaw = hpArr.map(([r, hp]) => hp);
          for (const fd of fd_ratios) {
            for (let i = 0; i < rpmArrRaw.length; i++) {
              const rpm = rpmArrRaw[i];
              const hp = hpArrRaw[i];
              const speed = rpmToSpeed(rpm, gr, fd);
              const tq    = (hp * 5252 / rpm) * (primary_drive * gr * fd);
              if (speed > maxX) maxX = speed;
              if (tq    > maxY) maxY = tq;
            }
          }
        }
      }
      maxY = Math.ceil(maxY / 100) * 100;
    }

    // Freeze and clear functions
    function freezeCurrentTraces() {
      // Detect current view at the very top
      const view = document.getElementById('viewSelect').value;

      // Handle Dyno view separately
      if (view === 'dyno') {
        freezeCount++;
        // Spacer to separate this frozen Dyno set in the legend
        frozenTraces.push({
          x: [null], y: [null],
          mode: 'lines',
          name: '\u00A0',  // non-breaking blank entry
          showlegend: true,
          hoverinfo: 'skip',
          line: { color: 'rgba(0,0,0,0)', width: 0 }
        });
        // Pick unique dash style per freeze, cycling with modulo
        const dashStyle = freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length];
        // Dyno freeze legend: DataSet name, Max HP, Max TQ
        const hn = document.getElementById("hpData").value;
        const hpArrRaw = hp_data_sets[hn].map(([r, hp]) => hp);
        const rpmArrRaw = hp_data_sets[hn].map(([r, hp]) => r);
        const engTq = hp_data_sets[hn].map(([rpm, hp]) => (hp * 5252) / rpm);
        // Clone Dyno torque curve for freezing (no legend entry), enable hover
        frozenTraces.push({
          x: rpmArrRaw,
          y: engTq,
          mode: 'lines',
          showlegend: false,
          hoverinfo: 'x+y',
          hovertemplate: 'RPM: %{x} RPM<br>Torque: %{y:.1f} lb-ft<extra></extra>',
          line: { color: gear_colors[0], shape: 'spline', dash: dashStyle, width: 2 },
          opacity: 0.3
        });
        // Clone Dyno HP curve for freezing (no legend entry), enable hover
        frozenTraces.push({
          x: rpmArrRaw,
          y: hpArrRaw,
          mode: 'lines',
          showlegend: false,
          hoverinfo: 'x+y',
          hovertemplate: 'RPM: %{x} RPM<br>HP: %{y:.1f}<extra></extra>',
          line: { color: gear_colors[1], shape: 'spline', dash: dashStyle, width: 2 },
          opacity: 0.3
        });
        const maxHP = Math.max(...hpArrRaw);
        const maxTQ = Math.max(...engTq);
        // Legend entries
        frozenTraces.push({
          x: [null], y: [null], mode: 'lines',
          name: hn, showlegend: true, hoverinfo: 'skip',
          line: { color: 'rgba(0,0,0,0)', width: 0 }
        });
        frozenTraces.push({
          x: [null], y: [null], mode: 'lines',
          name: `Max HP: ${maxHP.toFixed(1)}`, showlegend: true, hoverinfo: 'skip',
          line: {
            color: gear_colors[1],
            shape: 'spline',
            dash: dashStyle,
            width: 2
          }
        });
        frozenTraces.push({
          x: [null], y: [null], mode: 'lines',
          name: `Max TQ: ${maxTQ.toFixed(1)}`, showlegend: true, hoverinfo: 'skip',
          line: {
            color: gear_colors[0],
            shape: 'spline',
            dash: dashStyle,
            width: 2
          }
        });
        // Notification
        const notif = document.getElementById('freezeNotification');
        notif.style.display = 'block';
        setTimeout(() => { notif.style.display = 'none'; }, 2000);
        // Redraw including frozen Dyno traces
        plotTorque(false);
        return;
      }

      // Wheel TQ view
      if (!previousTraces.length) return;
      freezeCount++;
      // Insert spacer to separate the new frozen set in the legend
      frozenTraces.push({
        x: [null], y: [null],
        mode: 'lines',
        name: ' ',  // blank legend entry
        showlegend: true,
        hoverinfo: 'skip',
        line: { color: 'rgba(0,0,0,0)', width: 0 }
      });
      // Pick unique dash style per freeze, cycling with modulo
      const dashStyle = freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length];
      const f = document.getElementById("front").value;
      const r = document.getElementById("rear").value;
      const hn = document.getElementById("hpData").value;
      // Add a single group label trace for this freeze (smoothed)
      const groupLabel = `(F${f}/R${r} ${hn})`;
      frozenTraces.push({
        x: [null], y: [null],
        mode: 'lines',
        name: groupLabel,
        showlegend: true,
        hoverinfo: 'skip',
        line: {
          color: gear_colors[0],
          width: 2,
          dash: dashStyle,
          shape: 'spline'   // ensure smoothing
        }
      });

      // Clone only gear traces (skip connectors) to freeze, preserving hoverability
      previousTraces
        .filter(trace => trace.name && trace.name.startsWith('Gear '))
        .forEach(trace => {
          frozenTraces.push({
            x: trace.x,
            y: trace.y,
            customdata: trace.customdata,        // preserve RPM data for hover
            mode: trace.mode,
            name: trace.name,                    // original gear label only
            showlegend: true,
            hovertemplate: trace.hovertemplate,  // preserve the same hover template
            line: { ...trace.line, dash: dashStyle, opacity: 0.3 }
          });
        });

      // Compute shift points for this frozen set
      const fdFrozen = r / f;
      const hpArrFrozen = hpDenseSets[hn];
      const { wt: frozenWt, shift_rpm: frozenShiftRpm, shift_speed: frozenShiftSpeed } =
        computeShiftPoints(hpArrFrozen, fdFrozen, rpmDense);

      // Add frozen connector traces (vertical lines and labels)
      const baseRatio = 0.97, stepRatio = 0.03;
      frozenShiftSpeed && Object.keys(frozenShiftSpeed).forEach(gKey => {
        const g = parseInt(gKey);
        const xShift = frozenShiftSpeed[g];
        if (xShift != null) {
          const yLabel = Math.max(0, baseRatio - (freezeCount - 1) * stepRatio) * maxY;
          // Compute torque at the start of the next gear curve for frozen data
          const speedsNextFrozen = rpmDense.map(r => rpmToSpeed(r, gear_ratios[g + 1], fdFrozen));
          const idxNextFrozen = speedsNextFrozen.findIndex(s => s >= xShift);
          const torqueNextFrozen = idxNextFrozen !== -1 ? frozenWt[g + 1][idxNextFrozen] : 0;
          // Draw vertical line from just below label down to next gear start torque
          frozenConnectorTraces.push({
            x: [xShift, xShift],
            y: [yLabel, torqueNextFrozen],
            mode: 'lines',
            line: { color: gear_colors[g - 1], width: 1, dash: dashStyle },
            showlegend: false,
            hoverinfo: 'skip'
          });
          // Label
          frozenConnectorTraces.push({
            x: [xShift],
            y: [yLabel],
            mode: 'text',
            text: [`${xShift.toFixed(1)} MPH`],
            textposition: 'top center',
            textfont: { color: gear_colors[g - 1] },
            showlegend: false,
            hoverinfo: 'skip',
            cliponaxis: false
          });
        }
      });

      // Show temporary freeze notification
      const notif = document.getElementById('freezeNotification');
      notif.style.display = 'block';
      setTimeout(() => { notif.style.display = 'none'; }, 2000);

      // Redraw baseline to include frozen traces without animation
      plotTorque(false);
    }

    function clearFrozenTraces() {
      // Reset controls to default values
      document.getElementById("front").value = "14";
      document.getElementById("rear").value = "48";
      document.getElementById("hpData").value = "Stock";
      document.getElementById("truncateCross").checked = false;

      frozenTraces = [];
      freezeCount = 0;  // Reset label offset counter
      frozenConnectorTraces = [];
      plotTorque();
    }

    // Main plotting routine
    function plotTorque(animate = true) {
      // Determine which view is selected
      const view = document.getElementById('viewSelect').value;
      // Show Clip Lines checkbox only in Wheel TQ view
      const clipEl = document.getElementById('clipControl');
      clipEl.style.display = (view === 'wheel') ? 'inline-block' : 'none';
      // If switching between Dyno and Wheel views, clear any frozen legend entries
      if (lastView !== null && view !== lastView) {
        frozenTraces = [];
        frozenConnectorTraces = [];
        freezeCount = 0;
        previousTraces = [];
      }
      lastView = view;
      const front = parseInt(document.getElementById("front").value);
      const rear  = parseInt(document.getElementById("rear").value);
      const hpKey = document.getElementById("hpData").value;
      const rpmArr = rpmDense;
      const hpArr  = hpDenseSets[hpKey];
      const fd = rear / front;
      // Only apply dash style to new live traces after the first freeze+update
      const activeDash = (freezeCount > 1 && animate)
        ? freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length]
        : null;

      // Branch for Dyno view
      if (view === 'dyno') {
        const hpArrRaw = hp_data_sets[hpKey].map(([r, hp]) => hp);
        const rpmArrRaw = hp_data_sets[hpKey].map(([r, hp]) => r);
        // Engine torque from HP = (HP * 5252 / RPM)
        const engTq = hp_data_sets[hpKey].map(([rpm, hp]) => (hp * 5252) / rpm);
        const dynoTraces = [
          {
            x: rpmArrRaw,
            y: engTq,
            mode: 'lines',
            showlegend: false,
            hoverinfo: 'x+y',
            hovertemplate: 'RPM: %{x} RPM<br>Torque: %{y:.1f} lb-ft<extra></extra>',
            line: { color: gear_colors[0], shape: 'spline', width: 2 }
          },
          {
            x: rpmArrRaw,
            y: hpArrRaw,
            mode: 'lines',
            showlegend: false,
            hoverinfo: 'x+y',
            hovertemplate: 'RPM: %{x} RPM<br>HP: %{y:.1f}<extra></extra>',
            line: { color: gear_colors[1], shape: 'spline', width: 2 }
          }
        ];
        // Compute maximum dyno values
        const maxHP = Math.max(...hpArrRaw);
        const maxTQ = Math.max(...engTq);
        // Legend entries: Data set name, Max HP, Max TQ
        const legendTraces = [
          {
            x: [null], y: [null],
            mode: 'lines',
            name: hpKey,
            showlegend: true,
            hoverinfo: 'skip',
            line: { color: 'rgba(0,0,0,0)', width: 0 }
          },
          {
            x: [null], y: [null],
            mode: 'lines',
            name: `Max HP: ${maxHP.toFixed(1)}`,
            showlegend: true,
            hoverinfo: 'skip',
            line: { color: gear_colors[1], shape: 'spline', width: 2 }
          },
          {
            x: [null], y: [null],
            mode: 'lines',
            name: `Max TQ: ${maxTQ.toFixed(1)}`,
            showlegend: true,
            hoverinfo: 'skip',
            line: { color: gear_colors[0], shape: 'spline', width: 2 }
          }
        ];
        const dynoLayout = {
          title: 'HP and Torque',
          xaxis: { title: 'RPM', color: 'white', autorange: false, range: [rpmArrRaw[0], rpmArrRaw[rpmArrRaw.length - 1] + 2000] },
          yaxis: { title: 'HP / TQ', color: 'white', autorange: false, range: [0, dynoMaxHP] },
          plot_bgcolor: '#111',
          paper_bgcolor: '#111',
          font: { color: 'white' },
          transition: { duration: 1000, easing: 'cubic-in-out' },
          hovermode: 'closest',
          hoverdistance: 10
        };
        // Plot active dyno curves and summary first, then any frozen dyno sets (with blank spacer at the start)
        const allDynoTraces = [
          ...dynoTraces,
          ...legendTraces,
          ...frozenTraces
        ];
        if (animate) {
          Plotly.react('plot', allDynoTraces, dynoLayout, {responsive: true});
        } else {
          const staticLayout = { ...dynoLayout };
          delete staticLayout.transition;
          Plotly.newPlot('plot', allDynoTraces, staticLayout, {responsive: true});
        }
        // FORCE A RESIZE IMMEDIATELY and AGAIN after a brief delay
        const plotEl = document.getElementById('plot');
        Plotly.Plots.resize(plotEl);
        setTimeout(() => {
          Plotly.Plots.resize(plotEl);
        }, 100);
        previousTraces = []; // clear previousTraces for dyno
        return;  // skip wheel plotting
      }

      // --- Wheel TQ view as before ---
      // Compute optimal shift RPM and speed for each gear (for legend labels)
      const { wt, spd, shift_rpm, shift_speed } = computeShiftPoints(hpArr, fd, rpmArr);

      const truncate = document.getElementById("truncateCross").checked;

      // Legend entry for current sprocket set
      const groupLabel = `(F${front}/R${rear} ${hpKey})`;
      const traces = [];
      traces.push({
        x: [null], y: [null],
        mode: 'lines',
        name: groupLabel,
        showlegend: true,
        hoverinfo: 'skip',
        line: {
          color: gear_colors[0],
          width: 2,
          shape: 'spline'
        }
      });

      const connectors = [];

      for (let g = 1; g <= 6; g++) {
        const speeds = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g], fd));
        const torques = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], fd);
        let xPts = [], yPts = [], rpmPts = [];

        // Build point arrays, capturing RPM for hover
        for (let i = 0; i < rpmArr.length; i++) {
          const sp = speeds[i], tq = torques[i], rp = rpmArr[i];
          // include all when not truncating, or only within bounds
          const inRange = !truncate ||
            ((g > 1 ? sp >= shift_speed[g-1] : true) &&
             (g < 6 ? sp <= shift_speed[g]   : true));
          if (inRange) {
            xPts.push(sp);
            yPts.push(tq);
            rpmPts.push(rp);
          }
        }

        if (xPts.length) {
          // Build legend label with shift/redline info
          let label = `Gear ${g}`;
          if (g < 6 && shift_rpm[g] != null) {
            // For gears 1-5, show optimal shift point
            label += ` (${Math.round(shift_rpm[g])} RPM / ${shift_speed[g].toFixed(1)} MPH)`;
          } else if (g === 6) {
            // For 6th gear, show redline RPM and speed
            const redlineRPM = rpmArr[rpmArr.length - 1];
            const redlineSpeed = rpmToSpeed(redlineRPM, gear_ratios[g], fd);
            label += ` (${Math.round(redlineRPM)} RPM / ${redlineSpeed.toFixed(1)} MPH)`;
          }
          traces.push({
            x: xPts,
            y: yPts,
            customdata: rpmPts,
            mode: 'lines',
            name: label,
            line: {
              color: gear_colors[g-1],
              width: 2,
              shape: 'spline'
            },
            opacity: 1,
            hovertemplate:
              'Speed: %{x:.1f} MPH<br>' +
              'RPM: %{customdata:.0f} RPM<br>' +
              'Torque: %{y:.1f} lb-ft<extra></extra>'
          });
        }
      }

      // Build connector traces: vertical lines from label down to next gear torque
      const connectorTraces = [];
      for (let g = 1; g <= 5; g++) {
        const xShift = shift_speed[g];
        if (xShift != null) {
          // Compute label position
          const baseRatio = 0.97, stepRatio = 0.03;
          const yLabel = Math.max(0, baseRatio - freezeCount * stepRatio) * maxY;
          // Find the first torque value of the next gear at or beyond xShift
          const speedsNext = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g + 1], fd));
          const idxNext = speedsNext.findIndex(s => s >= xShift);
          const torqueNext = idxNext !== -1 ? wt[g + 1][idxNext] : 0;
          // Draw vertical line from label down to the next gear's start torque
          connectorTraces.push({
            x: [xShift, xShift],
            y: [yLabel, torqueNext],
            mode: 'lines',
            line: {
              color: gear_colors[g - 1],
              width: 2,
              dash: activeDash || 'solid'
            },
            showlegend: false,
            hoverinfo: 'skip'
          });
          // Place speed label at the top of the line
          connectorTraces.push({
            x: [xShift],
            y: [yLabel],
            mode: 'text',
            text: [`${xShift.toFixed(1)} MPH`],
            textposition: 'top center',
            textfont: { color: gear_colors[g - 1] },
            showlegend: false,
            hoverinfo: 'skip',
            cliponaxis: false
          });
        }
      }

      const layout = {
        transition: { duration: 1000, easing: 'cubic-in-out' },
        hovermode: 'closest',
        hoverdistance: 10,
        title: 'Wheel Torque / Shift Points',
        xaxis: {title:'Speed (MPH)', color:'white', range:[0,maxX]},
        yaxis: {title:'Wheel Torque (lb-ft)', color:'white', range:[0,maxY]},
        plot_bgcolor:'#111', paper_bgcolor:'#111', font:{color:'white'}
      };

      const allTraces = [...traces, ...connectorTraces, ...frozenTraces, ...frozenConnectorTraces];
      if (animate) {
        Plotly.react('plot', allTraces, layout, {responsive: true});
      } else {
        // Render without transition animation
        const staticLayout = { ...layout };
        delete staticLayout.transition;
        Plotly.newPlot('plot', allTraces, staticLayout, {responsive: true});
      }
      previousTraces = [...traces, ...connectorTraces];
      // Force a resize/redraw to ensure plot updates correctly
      Plotly.Plots.resize(document.getElementById('plot'));
    }

    // Initialize
    populateHpDropdown();
    getPlotBounds();
    plotTorque();

    // Redraw on window resize to fit new dimensions
    window.addEventListener('resize', () => {
      plotTorque(false);  // redraw without animation
    });
  </script>
</body>
</html>
