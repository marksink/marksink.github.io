<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gear Torque Plot</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { background-color: #111; color: white; font-family: Arial, sans-serif; }
    #plot { width: 90%; height: 600px; margin: auto; }
    .controls { text-align: center; margin-bottom: 20px; }
    .controls > * { margin: 0 6px; }
    button { margin-left: 10px; }
    label { user-select: none; }
  </style>
</head>
<body>
  <h1 style="text-align:center;">Gear Torque Curve</h1>
  <div class="controls">
    <label for="front">Front Sprocket:</label>
    <select id="front" onchange="plotTorque(true)">
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14" selected>14</option>
      <option value="15">15</option>
    </select>

    <label for="rear">Rear Sprocket:</label>
    <select id="rear" onchange="plotTorque(true)">
      <option value="47">47</option>
      <option value="48" selected>48</option>
      <option value="49">49</option>
      <option value="50">50</option>
      <option value="51">51</option>
      <option value="52">52</option>
      <option value="53">53</option>
    </select>

    <label for="hpData">HP Data:</label>
    <select id="hpData" onchange="plotTorque(true)">
      <option value="Stock" selected>Stock</option>
      <option value="Tuned">Tuned</option>
    </select>

    <label>
      <input type="checkbox" id="truncateCross" onchange="plotTorque(false)">
      Easy View
    </label>

    <button onclick="freezeCurrentTraces()">Freeze Graph</button>
    <button onclick="clearFrozenTraces()">Clear</button>
  </div>

  <div id="plot"></div>

  <script>
    // -------- Constants & data --------
    const primary_drive = 2.029;
    const tire_circ_in  = 77.15;
    const gear_ratios   = {1:2.92, 2:2.05, 3:1.62, 4:1.33, 5:1.15, 6:1.03};

    const rpm_data = [
      3500,4000,4500,5000,5500,6000,6500,7000,7500,
      8000,8500,9000,9500,10000,10500,11000,11500,12000,
      12500,13000,13500,14000,14250,14500,15000,15500,16000
    ];

    const hp_data_sets = {
      Stock: [
        12.5,15.8,17.8,19.8,22.3,24.4,26.5,28.7,31.1,
        34.2,37.1,41.1,43.8,45.5,48.9,53.1,55.1,53.6,
        53.6,52.3,52.4,52.2,52.1,52.3,52.4,50.8,50
      ],
      Tuned: [
        13.4,16.7,18.7,21.1,23.1,25.7,28.2,30.7,33.1,
        36.2,38.8,42.8,47.0,49.2,52.6,56.8,60.0,61.6,
        63.5,66.1,68.6,71.1,71.7,70.4,67.8,65.2,62.6
      ]
    };

    const gear_colors = ['#FF0000', '#00FFFF', '#00FF00', '#FFFF00', '#F012BE', '#FFFFFF'];

    // Available dash styles for frozen traces
    const freezeDashStyles = ['dot', 'dash', 'longdash', 'dashdot', 'solid'];
    let freezeCount = 0;

    // Number of interpolated data points per curve
    const densePoints = 750;

    // Create a dense RPM array from min to max of rpm_data
    const rpmDense = (() => {
      const arr = [];
      const minR = rpm_data[0];
      const maxR = rpm_data[rpm_data.length - 1];
      for (let i = 0; i <= densePoints; i++) {
        arr.push(minR + (maxR - minR) * (i / densePoints));
      }
      return arr;
    })();

    // Generate dense HP datasets by interpolating original dyno data
    const hpDenseSets = {};
    for (const key in hp_data_sets) {
      hpDenseSets[key] = rpmDense.map(r => interp1(rpm_data, hp_data_sets[key], r));
    }

    // -------- Globals --------
    let frozenTraces = [];
    let previousTraces = [];
    let maxX = 0, maxY = 0;

    // -------- Helpers --------
    function rpmToSpeed(rpm, gear_ratio, final_drive) {
      return rpm * tire_circ_in / (primary_drive * gear_ratio * final_drive * 1056);
    }

    function hpToWheelTorqueAt(rpmArr, hpArr, gear_ratio, final_drive) {
      const overall = primary_drive * gear_ratio * final_drive;
      return rpmArr.map((rpm, i) => (hpArr[i] * 5252 / rpm) * overall);
    }

    function lerp(x1, y1, x2, y2, y) {
      return x1 + (y - y1) * (x2 - x1) / (y2 - y1);
    }

    function interp1(xArr, yArr, x) {
      if (x <= xArr[0]) return yArr[0];
      if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
      let lo = 0, hi = xArr.length - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (xArr[mid] <= x) lo = mid; else hi = mid;
      }
      const x1 = xArr[lo], x2 = xArr[hi];
      const y1 = yArr[lo], y2 = yArr[hi];
      return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
    }

    // Compute optimal crossover shift RPMs and speeds
    function computeShiftPoints(hpArr, final_drive, rpmArr) {
      const wt = {}, spd = {};
      for (let g = 1; g <= 6; g++) {
        wt[g]  = hpToWheelTorqueAt(rpmArr, hpArr,      gear_ratios[g], final_drive);
        spd[g] = rpmArr.map(rpm => rpmToSpeed(rpm, gear_ratios[g], final_drive));
      }

      const shift_rpm   = {};
      const shift_speed = {};

      for (let g = 1; g <= 5; g++) {
        const ratio  = gear_ratios[g + 1] / gear_ratios[g];
        const diff   = [];

        for (let i = 0; i < rpmArr.length; i++) {
          const rp    = rpmArr[i];
          const curTq = wt[g][i];
          const nxtTq = interp1(rpmArr, wt[g + 1], rp * ratio);
          diff.push(nxtTq - curTq);
        }

        let idx = diff.findIndex(d => d >= 0);
        let shiftRPM;
        if (idx === -1) {
          shiftRPM = rpmArr[rpmArr.length - 1];
        } else if (idx === 0) {
          shiftRPM = rpmArr[0];
        } else {
          shiftRPM = lerp(
            rpmArr[idx - 1], diff[idx - 1],
            rpmArr[idx],     diff[idx],
            0
          );
        }

        shift_rpm[g]   = shiftRPM;
        shift_speed[g] = rpmToSpeed(shiftRPM, gear_ratios[g], final_drive);
      }

      return { wt, spd, shift_rpm, shift_speed };
    }

    // Pre-compute axis bounds
    function getPlotBounds() {
      const all_hp = Object.values(hp_data_sets);
      const fd_ratios = [48/13, 48/14, 50/13, 50/14];
      for (const gr of Object.values(gear_ratios)) {
        for (const hp of all_hp) {
          for (const fd of fd_ratios) {
            rpm_data.forEach((rpm, i) => {
              const speed = rpmToSpeed(rpm, gr, fd);
              const tq    = (hp[i] * 5252 / rpm) * (primary_drive * gr * fd);
              if (speed > maxX) maxX = speed;
              if (tq    > maxY) maxY = tq;
            });
          }
        }
      }
      maxY = Math.ceil(maxY / 100) * 100;
    }

    // Freeze and clear functions
    function freezeCurrentTraces() {
      if (!previousTraces.length) return;
      freezeCount++;
      const dashStyle = freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length];
      const f = document.getElementById("front").value;
      const r = document.getElementById("rear").value;
      const hn = document.getElementById("hpData").value;
      // Clone current traces with dashed style
      const frozen = previousTraces.map(trace => ({
        ...trace,
        name: `(F${f}/R${r} ${hn}) ${trace.name}`,
        opacity: 0.3,
        line: { ...trace.line, dash: dashStyle }
      }));
      // Add to frozenTraces array
      frozenTraces.push(...frozen);
      // Re-render plot without animation to apply new offset for labels
      plotTorque(false);
    }

    function clearFrozenTraces() {
      frozenTraces = [];
      freezeCount = 0;  // Reset label offset counter
      plotTorque();
    }

    // Main plotting routine
    function plotTorque(animate = true) {
      const front = parseInt(document.getElementById("front").value);
      const rear  = parseInt(document.getElementById("rear").value);
      const hpKey = document.getElementById("hpData").value;
      const rpmArr = rpmDense;
      const hpArr  = hpDenseSets[hpKey];
      const fd = rear / front;

      // Compute optimal shift RPM and speed for each gear (for legend labels)
      const { wt, spd, shift_rpm, shift_speed } = computeShiftPoints(hpArr, fd, rpmArr);

      const truncate = document.getElementById("truncateCross").checked;

      const traces = [];
      const connectors = [];

      for (let g = 1; g <= 6; g++) {
        const speeds = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g], fd));
        const torques= hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], fd);

        let xPts = speeds.slice(), yPts = torques.slice();

        if (truncate) {
          const lower = g > 1 && shift_speed[g-1]!=null ? shift_speed[g-1] : -Infinity;
          const upper = g < 6 && shift_speed[g]!=null   ? shift_speed[g]   : Infinity;
          xPts = []; yPts = [];
          for (let i=0; i<speeds.length; i++) {
            if (speeds[i]>=lower && speeds[i]<=upper) {
              xPts.push(speeds[i]);
              yPts.push(torques[i]);
            }
          }
          // Vertical connector
          // if (g>1 && shift_speed[g-1]!=null) {
          //   const xs = shift_speed[g-1];
          //   const yp= interp1(spd[g-1], wt[g-1], xs);
          //   const yc= interp1(spd[g],   wt[g],   xs);
          //   connectors.push({
          //     x: [xs, xs],
          //     y: [yp, yc],
          //     mode: 'lines',
          //     name: `Conn ${g-1}->${g}`,
          //     line: {color: gear_colors[g-1], width:1, dash:'dot'},
          //     hoverinfo:'skip', showlegend:false
          //   });
          // }
        }

        if (xPts.length) {
          // Build legend label with shift/redline info
          let label = `Gear ${g}`;
          if (g < 6 && shift_rpm[g] != null) {
            // For gears 1-5, show optimal shift point
            label += ` (shift @ ${Math.round(shift_rpm[g])} RPM / ${shift_speed[g].toFixed(1)} MPH)`;
          } else if (g === 6) {
            // For 6th gear, show redline RPM and speed
            const redlineRPM = rpmArr[rpmArr.length - 1];
            const redlineSpeed = rpmToSpeed(redlineRPM, gear_ratios[g], fd);
            label += ` (${Math.round(redlineRPM)} RPM / ${redlineSpeed.toFixed(1)} MPH)`;
          }
          traces.push({
            x: xPts, y: yPts,
            mode: 'lines',
            name: label,
            line: {color: gear_colors[g-1], width:2, shape:'spline'},
            opacity:1
          });
        }
      }

      // Scatter traces for connectors and labels (will animate)
      const connectorTraces = [];
      for (let g = 1; g <= 5; g++) {
        const xShift = shift_speed[g];
        if (xShift != null) {
          // vertical line trace
          connectorTraces.push({
            x: [xShift, xShift],
            y: [0, maxY],
            mode: 'lines',
            line: { color: gear_colors[g - 1], width: 1, dash: 'dash' },
            showlegend: false,
            hoverinfo: 'skip'
          });
          // Stack labels downward by 2% of y-range per freeze, starting just below top
          const baseRatio = 0.97;
          const stepRatio = 0.03;
          const yLabelRatio = Math.max(0, baseRatio - (freezeCount - 1) * stepRatio);
          const yLabel = yLabelRatio * maxY;
          connectorTraces.push({
            x: [xShift],
            y: [yLabel],              // fixed offset at 95% of y-axis
            mode: 'text',
            text: [`${xShift.toFixed(1)} MPH`],
            textposition: 'top center',
            textfont: { color: gear_colors[g - 1] },
            showlegend: false,
            hoverinfo: 'skip',
            cliponaxis: false
          });
        }
      }

      const layout = {
        transition: { duration: 1000, easing: 'cubic-in-out' },
        title: 'Torque vs Speed per Gear',
        xaxis: {title:'Speed (MPH)', color:'white', range:[0,maxX]},
        yaxis: {title:'Wheel Torque (lb-ft)', color:'white', range:[0,maxY]},
        plot_bgcolor:'#111', paper_bgcolor:'#111', font:{color:'white'}
      };

      const allTraces = [...frozenTraces, ...traces, ...connectorTraces];
      if (animate) {
        Plotly.react('plot', allTraces, layout);
      } else {
        // Render without transition animation
        const staticLayout = { ...layout };
        delete staticLayout.transition;
        Plotly.newPlot('plot', allTraces, staticLayout);
      }
      previousTraces = [...traces, ...connectorTraces];
    }

    // Initialize
    getPlotBounds();
    plotTorque();
  </script>
</body>
</html>
