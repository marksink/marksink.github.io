<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wheel Torque</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { background-color: #111; color: white; font-family: Arial, sans-serif; }
    #plot {
      width: 90%;
      max-width: calc(100vh * (16 / 9));   /* Prevent width:height exceeding 16:9 */
      aspect-ratio: 16 / 9;                 /* Always maintain 16:9 ratio */
      max-height: 90vh;                     /* Ensure graph fits vertically in viewport */
      margin: auto;
    }
    .controls { text-align: center; margin-bottom: 20px; }
    .controls > * { margin: 0 6px; }
    button { margin-left: 10px; }
    label { user-select: none; }
  </style>
</head>
<body>
  <h1 style="text-align:center;">Wheel Torque</h1>
  <div class="controls">
    <label for="front">Front Sprocket:</label>
    <select id="front" onchange="plotTorque(true)">
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14" selected>14</option>
      <option value="15">15</option>
    </select>

    <label for="rear">Rear Sprocket:</label>
    <select id="rear" onchange="plotTorque(true)">
      <option value="47">47</option>
      <option value="48" selected>48</option>
      <option value="49">49</option>
      <option value="50">50</option>
      <option value="51">51</option>
      <option value="52">52</option>
      <option value="53">53</option>
    </select>

    <label for="hpData">HP Data:</label>
    <select id="hpData" onchange="plotTorque(true)">
      <option value="Stock" selected>Stock</option>
      <option value="Tuned">Tuned</option>
    </select>

    <label>View:</label>
    <label><input type="radio" name="view" value="wheel" checked onchange="plotTorque(true)">Wheel TQ</label>
    <label><input type="radio" name="view" value="dyno" onchange="plotTorque(true)">Dyno</label>

    <label>
      <input type="checkbox" id="truncateCross" onchange="plotTorque(false)">
      Easy View
    </label>

    <button onclick="freezeCurrentTraces()">Compare</button>
    <button onclick="clearFrozenTraces()">Reset</button>
  </div>

  <div id="plot" style="position: relative;">
    <div id="freezeNotification" style="
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255,255,255,0.9);
        color: #111;
        padding: 8px 12px;
        border-radius: 4px;
        font-weight: bold;
        display: none;
        z-index: 1000;
    ">
      Select New Options!
    </div>
  </div>

  <script>
    // -------- Constants & data --------
    const primary_drive = 2.029;
    const tire_circ_in  = 77.15;
    const gear_ratios   = {1:2.92, 2:2.05, 3:1.62, 4:1.33, 5:1.15, 6:1.03};

    const rpm_data = [
      3500,4000,4500,5000,5500,6000,6500,7000,7500,
      8000,8500,9000,9500,10000,10500,11000,11500,12000,
      12500,13000,13500,14000,14250,14500,15000,15500,16000
    ];

    const hp_data_sets = {
      Stock: [
        12.5,15.8,17.8,19.8,22.3,24.4,26.5,28.7,31.1,
        34.2,37.1,41.1,43.8,45.5,48.9,53.1,55.1,53.6,
        53.6,52.3,52.4,52.2,52.1,52.3,52.4,50.8,50
      ],
      Tuned: [
        13.4,16.7,18.7,21.1,23.1,25.7,28.2,30.7,33.1,
        36.2,38.8,42.8,47.0,49.2,52.6,56.8,60.0,61.6,
        63.5,66.1,68.6,71.1,71.7,70.4,67.8,65.2,62.6
      ]
    };

    // Precompute Dyno view y-axis maximum based on max HP across all datasets
    const dynoMaxHP = (() => {
      let maxVal = 0;
      Object.values(hp_data_sets).forEach(arr => {
        arr.forEach(v => { if (v > maxVal) maxVal = v; });
      });
      // Round up to nearest 10
      return Math.ceil(maxVal / 10) * 10;
    })();

    const gear_colors = ['#FF0000', '#00FFFF', '#00FF00', '#FFFF00', '#F012BE', '#FFFFFF'];

    // Available dash styles for frozen traces
    const freezeDashStyles = ['dot', 'dash', 'longdash', 'dashdot', 'solid'];
    let freezeCount = 0;

    // Number of interpolated data points per curve
    const densePoints = 750;

    // Create a dense RPM array from min to max of rpm_data
    const rpmDense = (() => {
      const arr = [];
      const minR = rpm_data[0];
      const maxR = rpm_data[rpm_data.length - 1];
      for (let i = 0; i <= densePoints; i++) {
        arr.push(minR + (maxR - minR) * (i / densePoints));
      }
      return arr;
    })();

    // Generate dense HP datasets by interpolating original dyno data
    const hpDenseSets = {};
    for (const key in hp_data_sets) {
      hpDenseSets[key] = rpmDense.map(r => interp1(rpm_data, hp_data_sets[key], r));
    }

    // -------- Globals --------
    let frozenTraces = [];
    let frozenConnectorTraces = [];
    let previousTraces = [];
    let maxX = 0, maxY = 0;

    // -------- Helpers --------
    function rpmToSpeed(rpm, gear_ratio, final_drive) {
      return rpm * tire_circ_in / (primary_drive * gear_ratio * final_drive * 1056);
    }

    function hpToWheelTorqueAt(rpmArr, hpArr, gear_ratio, final_drive) {
      const overall = primary_drive * gear_ratio * final_drive;
      return rpmArr.map((rpm, i) => (hpArr[i] * 5252 / rpm) * overall);
    }

    function lerp(x1, y1, x2, y2, y) {
      return x1 + (y - y1) * (x2 - x1) / (y2 - y1);
    }

    function interp1(xArr, yArr, x) {
      if (x <= xArr[0]) return yArr[0];
      if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
      let lo = 0, hi = xArr.length - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (xArr[mid] <= x) lo = mid; else hi = mid;
      }
      const x1 = xArr[lo], x2 = xArr[hi];
      const y1 = yArr[lo], y2 = yArr[hi];
      return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
    }

    // Compute optimal crossover shift RPMs and speeds
    function computeShiftPoints(hpArr, final_drive, rpmArr) {
      const wt = {}, spd = {};
      for (let g = 1; g <= 6; g++) {
        wt[g]  = hpToWheelTorqueAt(rpmArr, hpArr,      gear_ratios[g], final_drive);
        spd[g] = rpmArr.map(rpm => rpmToSpeed(rpm, gear_ratios[g], final_drive));
      }

      const shift_rpm   = {};
      const shift_speed = {};

      for (let g = 1; g <= 5; g++) {
        const ratio  = gear_ratios[g + 1] / gear_ratios[g];
        const diff   = [];

        for (let i = 0; i < rpmArr.length; i++) {
          const rp    = rpmArr[i];
          const curTq = wt[g][i];
          const nxtTq = interp1(rpmArr, wt[g + 1], rp * ratio);
          diff.push(nxtTq - curTq);
        }

        let idx = diff.findIndex(d => d >= 0);
        let shiftRPM;
        if (idx === -1) {
          shiftRPM = rpmArr[rpmArr.length - 1];
        } else if (idx === 0) {
          shiftRPM = rpmArr[0];
        } else {
          shiftRPM = lerp(
            rpmArr[idx - 1], diff[idx - 1],
            rpmArr[idx],     diff[idx],
            0
          );
        }

        shift_rpm[g]   = shiftRPM;
        shift_speed[g] = rpmToSpeed(shiftRPM, gear_ratios[g], final_drive);
      }

      return { wt, spd, shift_rpm, shift_speed };
    }

    // Pre-compute axis bounds
    function getPlotBounds() {
      const all_hp = Object.values(hp_data_sets);
      const fd_ratios = [48/13, 48/14, 50/13, 50/14];
      for (const gr of Object.values(gear_ratios)) {
        for (const hp of all_hp) {
          for (const fd of fd_ratios) {
            rpm_data.forEach((rpm, i) => {
              const speed = rpmToSpeed(rpm, gr, fd);
              const tq    = (hp[i] * 5252 / rpm) * (primary_drive * gr * fd);
              if (speed > maxX) maxX = speed;
              if (tq    > maxY) maxY = tq;
            });
          }
        }
      }
      maxY = Math.ceil(maxY / 100) * 100;
    }

    // Freeze and clear functions
    function freezeCurrentTraces() {
      if (!previousTraces.length) return;
      freezeCount++;
      // Insert spacer to separate the new frozen set in the legend
      frozenTraces.push({
        x: [null], y: [null],
        mode: 'lines',
        name: ' ',  // blank legend entry
        showlegend: true,
        hoverinfo: 'skip',
        line: { color: 'rgba(0,0,0,0)', width: 0 }
      });
      const dashStyle = freezeDashStyles[(freezeCount - 1) % freezeDashStyles.length];
      const f = document.getElementById("front").value;
      const r = document.getElementById("rear").value;
      const hn = document.getElementById("hpData").value;
      // Add a single group label trace for this freeze (smoothed)
      const groupLabel = `(F${f}/R${r} ${hn})`;
      frozenTraces.push({
        x: [null], y: [null],
        mode: 'lines',
        name: groupLabel,
        showlegend: true,
        hoverinfo: 'skip',
        line: {
          color: gear_colors[0],
          width: 2,
          dash: dashStyle,
          shape: 'spline'   // ensure smoothing
        }
      });

      // Clone only gear traces (skip connectors) to freeze, preserving hoverability
      previousTraces
        .filter(trace => trace.name && trace.name.startsWith('Gear '))
        .forEach(trace => {
          frozenTraces.push({
            x: trace.x,
            y: trace.y,
            customdata: trace.customdata,        // preserve RPM data for hover
            mode: trace.mode,
            name: trace.name,                    // original gear label only
            showlegend: true,
            hovertemplate: trace.hovertemplate,  // preserve the same hover template
            line: { ...trace.line, dash: dashStyle, opacity: 0.3 }
          });
        });

      // Compute shift points for this frozen set
      const fdFrozen = r / f;
      const hpArrFrozen = hpDenseSets[hn];
      const { shift_speed: frozenShiftSpeed } = computeShiftPoints(hpArrFrozen, fdFrozen, rpmDense);

      // Add frozen connector traces (vertical lines and labels)
      const baseRatio = 0.97, stepRatio = 0.03;
      frozenShiftSpeed && Object.keys(frozenShiftSpeed).forEach(gKey => {
        const g = parseInt(gKey);
        const xShift = frozenShiftSpeed[g];
        if (xShift != null) {
          const yLabel = Math.max(0, baseRatio - (freezeCount - 1) * stepRatio) * maxY;
          // Vertical line
          frozenConnectorTraces.push({
            x: [xShift, xShift],
            y: [0, maxY],
            mode: 'lines',
            line: { color: gear_colors[g - 1], width: 1, dash: dashStyle },
            showlegend: false,
            hoverinfo: 'skip'
          });
          // Label
          frozenConnectorTraces.push({
            x: [xShift],
            y: [yLabel],
            mode: 'text',
            text: [`${xShift.toFixed(1)} MPH`],
            textposition: 'top center',
            textfont: { color: gear_colors[g - 1] },
            showlegend: false,
            hoverinfo: 'skip',
            cliponaxis: false
          });
        }
      });

      // Show temporary freeze notification
      const notif = document.getElementById('freezeNotification');
      notif.style.display = 'block';
      setTimeout(() => { notif.style.display = 'none'; }, 2000);

      // Redraw baseline to include frozen traces without animation
      plotTorque(false);
    }

    function clearFrozenTraces() {
      // Reset controls to default values
      document.getElementById("front").value = "14";
      document.getElementById("rear").value = "48";
      document.getElementById("hpData").value = "Stock";
      document.getElementById("truncateCross").checked = false;

      frozenTraces = [];
      freezeCount = 0;  // Reset label offset counter
      frozenConnectorTraces = [];
      plotTorque();
    }

    // Main plotting routine
    function plotTorque(animate = true) {
      // Determine which view is selected
      const view = document.querySelector('input[name="view"]:checked').value;
      const front = parseInt(document.getElementById("front").value);
      const rear  = parseInt(document.getElementById("rear").value);
      const hpKey = document.getElementById("hpData").value;
      const rpmArr = rpmDense;
      const hpArr  = hpDenseSets[hpKey];
      const fd = rear / front;

      // Branch for Dyno view
      if (view === 'dyno') {
        const hpArrRaw = hp_data_sets[hpKey];
        // Engine torque from HP = (HP * 5252 / RPM)
        const engTq = rpm_data.map((rpm, i) => (hpArrRaw[i] * 5252) / rpm);
        const dynoTraces = [
          {
            x: rpm_data,
            y: engTq,
            mode: 'lines',
            name: 'Engine Torque (lb-ft)',
            line: { color: gear_colors[0], shape: 'spline', width: 2 }
          },
          {
            x: rpm_data,
            y: hpArrRaw,
            mode: 'lines',
            name: 'HP',
            line: { color: gear_colors[1], shape: 'spline', width: 2 }
          }
        ];
        const dynoLayout = {
          title: 'Dyno: HP and Torque vs RPM',
          xaxis: { title: 'RPM', color: 'white', autorange: false, range: [rpm_data[0], rpm_data[rpm_data.length - 1] + 2000] },
          yaxis: { title: 'HP / TQ', color: 'white', autorange: false, range: [0, dynoMaxHP] },
          plot_bgcolor: '#111',
          paper_bgcolor: '#111',
          font: { color: 'white' },
          transition: { duration: 1000, easing: 'cubic-in-out' },
          hovermode: 'closest',
          hoverdistance: 10
        };
        if (animate) {
          Plotly.react('plot', dynoTraces, dynoLayout, {responsive: true});
        } else {
          const staticLayout = { ...dynoLayout };
          delete staticLayout.transition;
          Plotly.newPlot('plot', dynoTraces, staticLayout, {responsive: true});
        }
        // FORCE A RESIZE IMMEDIATELY and AGAIN after a brief delay
        const plotEl = document.getElementById('plot');
        Plotly.Plots.resize(plotEl);
        setTimeout(() => {
          Plotly.Plots.resize(plotEl);
        }, 100);
        previousTraces = []; // clear previousTraces for dyno
        return;  // skip wheel plotting
      }

      // --- Wheel TQ view as before ---
      // Compute optimal shift RPM and speed for each gear (for legend labels)
      const { wt, spd, shift_rpm, shift_speed } = computeShiftPoints(hpArr, fd, rpmArr);

      const truncate = document.getElementById("truncateCross").checked;

      // Legend entry for current sprocket set
      const groupLabel = `(F${front}/R${rear} ${hpKey})`;
      const traces = [];
      traces.push({
        x: [null], y: [null],
        mode: 'lines',
        name: groupLabel,
        showlegend: true,
        hoverinfo: 'skip',
        line: { color: gear_colors[0], width: 2, shape: 'spline' }
      });

      const connectors = [];

      for (let g = 1; g <= 6; g++) {
        const speeds = rpmArr.map(r => rpmToSpeed(r, gear_ratios[g], fd));
        const torques = hpToWheelTorqueAt(rpmArr, hpArr, gear_ratios[g], fd);
        let xPts = [], yPts = [], rpmPts = [];

        // Build point arrays, capturing RPM for hover
        for (let i = 0; i < rpmArr.length; i++) {
          const sp = speeds[i], tq = torques[i], rp = rpmArr[i];
          // include all when not truncating, or only within bounds
          const inRange = !truncate ||
            ((g > 1 ? sp >= shift_speed[g-1] : true) &&
             (g < 6 ? sp <= shift_speed[g]   : true));
          if (inRange) {
            xPts.push(sp);
            yPts.push(tq);
            rpmPts.push(rp);
          }
        }

        if (xPts.length) {
          // Build legend label with shift/redline info
          let label = `Gear ${g}`;
          if (g < 6 && shift_rpm[g] != null) {
            // For gears 1-5, show optimal shift point
            label += ` (${Math.round(shift_rpm[g])} RPM / ${shift_speed[g].toFixed(1)} MPH)`;
          } else if (g === 6) {
            // For 6th gear, show redline RPM and speed
            const redlineRPM = rpmArr[rpmArr.length - 1];
            const redlineSpeed = rpmToSpeed(redlineRPM, gear_ratios[g], fd);
            label += ` (${Math.round(redlineRPM)} RPM / ${redlineSpeed.toFixed(1)} MPH)`;
          }
          traces.push({
            x: xPts,
            y: yPts,
            customdata: rpmPts,
            mode: 'lines',
            name: label,
            line: { color: gear_colors[g-1], width: 2, shape: 'spline' },
            opacity: 1,
            hovertemplate:
              'Speed: %{x:.1f} MPH<br>' +
              'RPM: %{customdata:.0f} RPM<br>' +
              'Torque: %{y:.1f} lb-ft<extra></extra>'
          });
        }
      }

      // Scatter traces for connectors and labels (will animate)
      const connectorTraces = [];
      for (let g = 1; g <= 5; g++) {
        const xShift = shift_speed[g];
        if (xShift != null) {
          // vertical line trace
          connectorTraces.push({
            x: [xShift, xShift],
            y: [0, maxY],
            mode: 'lines',
            line: { color: gear_colors[g - 1], width: 1, dash: 'dash' },
            showlegend: false,
            hoverinfo: 'skip'
          });
          // Stack labels downward by 2% of y-range per freeze, starting just below top
          const baseRatio = 0.97;
          const stepRatio = 0.03;
          const yLabelRatio = Math.max(0, baseRatio - freezeCount * stepRatio);
          const yLabel = yLabelRatio * maxY;
          connectorTraces.push({
            x: [xShift],
            y: [yLabel],              // fixed offset at 95% of y-axis
            mode: 'text',
            text: [`${xShift.toFixed(1)} MPH`],
            textposition: 'top center',
            textfont: { color: gear_colors[g - 1] },
            showlegend: false,
            hoverinfo: 'skip',
            cliponaxis: false
          });
        }
      }

      const layout = {
        transition: { duration: 1000, easing: 'cubic-in-out' },
        hovermode: 'closest',
        hoverdistance: 10,
        title: 'Torque vs Speed per Gear',
        xaxis: {title:'Speed (MPH)', color:'white', range:[0,maxX]},
        yaxis: {title:'Wheel Torque (lb-ft)', color:'white', range:[0,maxY]},
        plot_bgcolor:'#111', paper_bgcolor:'#111', font:{color:'white'}
      };

      const allTraces = [...traces, ...connectorTraces, ...frozenTraces, ...frozenConnectorTraces];
      if (animate) {
        Plotly.react('plot', allTraces, layout, {responsive: true});
      } else {
        // Render without transition animation
        const staticLayout = { ...layout };
        delete staticLayout.transition;
        Plotly.newPlot('plot', allTraces, staticLayout, {responsive: true});
      }
      previousTraces = [...traces, ...connectorTraces];
      // Force a resize/redraw to ensure plot updates correctly
      Plotly.Plots.resize(document.getElementById('plot'));
    }

    // Initialize
    getPlotBounds();
    plotTorque();

    // Redraw on window resize to fit new dimensions
    window.addEventListener('resize', () => {
      plotTorque(false);  // redraw without animation
    });
  </script>
</body>
</html>
